将dtype=np.int改为dtype=int

重要难题：2024：8，10 ; 2023：8 ；2021：2,10
一、count的功能和sum不一样：count统计的是行数，sum统计的是这么多行的这个字段的值的累加和
二、having关键字可以对组进行条件过滤
三、排序使用order by。语法为order by + 按哪个字段 + 升序（ASC）/降序（DESC）
四、如果某个字段为空不能用=号，要用is，即 is null而不是 = null
五、left(string,length)函数从左侧开始截取字符串的前几个字符；right(string,length)函数从右侧开始截取字符串的前几个字符；substring(string,begin,length)函数从左侧的第begin个字符开始截取length个字符。
六、一旦要使用自然连接，就要注意了，你连接的那些表十有八九是要起别名操作的,然后之后所有的字段都要用 别名.字段 这样的形式引用了。
七、查询的时候所有的数据都必须使用语句获取，不能用眼睛看见了某个表的结构就直接认为已经知道了
八、是exists不是exist，要加上一个s
九、自然连接要少用，尽量使用left join，right join 或者 join
十、等号的右边可以连接子查询语句，这经常在复杂任务中用到
十一、使用limit length 可以控制获取的表的行数，例如执行limit 1则只获取结果表的第一行
十二、尽量不要使用*符号
十三、在主查询语句中，使用了聚合函数就一定要用group by但是在子查询语句中，聚合函数却可以直接使用。
十四、round(num,length)：能够指定数字num保留length位小数点



2024：
①select distinct stu_id from takes where mid_score > 95 and fin_score >95;
②select cor_id,avg(mid_score*0.3 + fin_score*0.7) as avg_score from takes group by cor_id;
③select cor_id,sum(stu_id) as cor_select_num from takes group by cor_id having sum(stu_id)>=10 order by cor_select_num DESC;
④select stu_id from student where idcard  is null or left(idcard,2) = '12';
⑤select s.stu_id,s.stu_name,avg(t,fin_score) as avg_fin_score from student s natural join takes t where s.col_id = (select col_id from college where col_name = "金融学院") group by s.stu_id;
⑥select s.stu_id,s.stu_name from student s where EXISTS (select stu_name from student where stu_name = s.stu_name and stu_id != s.stu_id);
⑦select distinct s.stu_id,s.stu_name from student s left join takes t  on s.stu_id = t.stu_id where s.stu_id not in (select t.stu_id from takes t natural join course c where c.credits = 3.5);

⑧SELECT s.stu_id
FROM student s
JOIN takes t ON s.stu_id = t.stu_id
JOIN course c ON t.cor_id = c.cor_id
WHERE c.col_id = (SELECT col_id FROM college WHERE col_name='计算机学院')
GROUP BY s.stu_id
HAVING COUNT(DISTINCT t.cor_id) = (
    SELECT COUNT(*) 
    FROM course 
    WHERE col_id = (SELECT col_id FROM college WHERE col_name='计算机学院')
)

⑨select col_id,col_name from college c left join student s on c.col_id = s.col_id group by c.col_id having count(s.stu_id) < 3;  

⑩

2023：
①select empid,empname,age,depid from Employee where left(empname,1) = '张' and age>30 order by empid ASC;

②select p.proid,p.projectname,p.budget,c.catname from Project p natural join Category c where p.budget>50000;

③select e.empname,count(w.proid) as pronum,avg(p.budget) as meanbudget from Employee e left join Workson w on e.empid = w.empid join Project p on w.proid = p.proid group by e.empname;

④select d.depid,d.depname,count(e.empid) as empNum from (select depid,depname from Department where location = '天津')d join Employee e on d.depid = e.depid group by d.depid,d.depname;

⑤select distinct e.empid,e.empname,e.age,e.sex,e.depid from Employee e join Workson w on e.empid = w.empid join Project p on w.proid = p.proid join Category c on p.catid = c.catid where e.age>35 and c.catname = '软件类';

⑥select c.catid,count(w.job) as jobNum from (select proid,job from Workson where empid = '10102')w join  Project p on w.proid = p.proid right join Category c on p.catid=c.catid group by c.catid;

⑦select p.projectname,min(e.age),max(e.age) from Employee e join Workson w on e.empid = w.empid join Project p on p.proid = w.proid group by p.projectname;

⑧select e.empid,e.empname,e.age from (select e.empid,e.empname,e.age from Employee e join Department d on e.depid = d.depid where d.depname = '开发部' and e.sex = '男')e join (select d.depid,max(e.age)as age from (select * from Employee where sex='男')e join (select depid from Department where depname='开发部')d on d.depid = e.depid group by d.depid)max_age on max_age.age = e.age;

⑨select p.proid,p.projectname,p.budget,count(w.empid) as empNum from  Project p join Workson w on p.proid = w.proid group by p.proid having empNum<=3;

⑩select empid,empname,age,sex,depid from Employee where empid not in (select e.empid from Employee e join Workson w on e.empid = w.empid natural join (select proid from Project where budget>160000)p) and age>30;

2022：
①select empid,empname,age,depid from Employee where left(empname,1) = '王' order by age ASC;

②select e.empid,e.empname,e.age,d.location from Employee e join Department d on e.depid = e.depid where e.sex = '男';

③select p.proid,p.projectname,p.budget from Project p join Category c on p.catid = c.catid where c.catid = 'c2' order by p.budget ASC limit 1;

④select d.depid,d.depname,d.location,count(e.empid) as empCount from Department d join Employee e on e.depid = d.depid group by d.depid having empCount<=5;

⑤select empid,empname,age,sex,depid from Employee where empid not in (select e.empid from Employee e join Workson w on e.empid = w.empid join Project p on w.proid = p.proid join Category c on c.catid = p.catid where c.catname = '设计类') and sex = '男';

⑥select e.empid,e.empname,count(p.proid) as procnt from (select e.empid,e.empname from Employee e join Workson w on e.empid = w.empid join Project p on w.proid = p.proid join Department d on e.depid = d.depid where d.location = '北京' and p.projectname = '产品推广')e join Workson w on e.empid = w.empid join Project p on w.proid = p.proid group by e.empid;

2021：
①select c.catid,sum(b.price) as totalprice from Book b natural join Category c group by c.catid;

②select bookname,author,price,round((select avg(price) from Book),1) as avgprice from Book where price>round((select avg(price) from Book),1) order by price DESC;

③select degree,count(majorid) from (select distinct degree,majorid from Student)Student group by degree;

④select b.bookid,b.bookname,b.author,b.price from Book b join Category c on b.catid = c.catid where c.catname = '政治' order by b.price ASC;

⑤select s.stuid,s.stuname from Student s natural join Major m where m.department = '计算机与控制工程学院';

⑥select bookid,bookname,author from Book natural join Borrow where catid = 'c1' order by borrowdate DESC limit 1;

⑦select b.bookid,b.bookname,b.author from Book b join Borrow bo on b.bookid = bo.bookid where bo.stuid = '200810111';

⑧select s.stuname,max(b.price) as highestprice,min(b.price) as lowestprice from Student s join Borrow bo on s.stuid = bo.stuid join Book b on bo.bookid = b.bookid group by stuname having left(stuname,1) = '王';

⑨select distinct s.stuid,stuname,degree,majorid from Student s join Borrow bo on s.stuid = bo.stuid join Book b on bo.bookid = b.bookid join Category c on c.catid = b.catid where c.catname = '计算机技术';

⑩select stuid, stuname from student where  
not exists (select catid from category where catid not in  
(select book.catid from category,borrow,book 
where category.catid=book.catid and book.bookid=borrow.bookid and 
borrow.stuid=student.stuid))